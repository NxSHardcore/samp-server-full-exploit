#include "main.hpp"

unsigned short server_checker::ms_usiMagicKey;
unsigned short server_checker::ms_siPort;
bool server_checker::ms_bInitialized;

std::string server_checker::ms_strTargetAddress;

server_checker::server_checker(const std::string& address, unsigned short port)
{
	m_skServer.sin_family = AF_INET;
	m_skServer.sin_addr.s_addr = inet_addr(address.c_str());
	m_skServer.sin_port = htons(port);

	server_checker::ms_siPort = port;

	m_iServerLength = sizeof(m_skServer);
}

void server_checker::Initialize()
{
#ifdef _WIN32
	WSADATA wsaData;

	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
	{
		throw std::runtime_error("An error ocurred while attemping to initialize WinSock!");
	}

	m_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (m_sock == INVALID_SOCKET)
	{
		throw std::runtime_error("An error ocurred while attemping to create the sockets!");
	}

#else
	m_sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (m_sock < 0)
	{
		throw std::runtime_error("An error ocurred while attemping to create the sockets!");
	}
#endif
}

void server_checker::Update()
{
	char lol[3];
	lol[0] = 24; // Conncookie request

	encrypt::kyretardizeDatagram((unsigned char*)lol, 3, server_checker::ms_siPort, 0);

	int len = sendto(m_sock, (char*)encrypt::encrBuffer, 4, 0, (const sockaddr*)&m_skServer, sizeof(struct sockaddr_in));

	// Will contain the results
	char data[576];

	while (true)
	{
		len = recvfrom(m_sock, data, 576, 0, (struct sockaddr*)&m_skServer, &m_iServerLength);

		if (len > 0)
		{
			if (data[0] == 26) // Open connection cookie
			{
				unsigned short cookievalue = *(unsigned short*)&data[1];
				server_checker::ms_usiMagicKey = (unsigned short)(inet_addr(MAIN_IP) ^ cookievalue);

				std::cout << "Updated magic key! new value is: " << server_checker::ms_usiMagicKey << std::endl;

				if (!server_checker::ms_bInitialized)
				{
					server_checker::ms_bInitialized = true;
				}

				char c[3];

				// We have to respond to the already requested conncookie, otherwise they'll discover our real ip address
				c[0] = 24; // Open connection cookie
				*(unsigned short*)&c[1] = (unsigned short)(cookievalue ^ NETCOOKIE);
				
				encrypt::kyretardizeDatagram((unsigned char*)c, 3, server_checker::ms_siPort, 0);
				
				sendto(m_sock, (char*)encrypt::encrBuffer, 4, 0, (const sockaddr*)&m_skServer, sizeof(m_skServer));
				break;
			}
		}

		std::this_thread::sleep_for(std::chrono::milliseconds(1));
	}
}

server_checker::~server_checker()
{
#ifdef _WIN32
	closesocket(m_sock);
#else
	close(m_sock);
#endif
}
